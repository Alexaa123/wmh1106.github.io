## 自定义指令

1. 自定义指令，都写在实例的`directives`属性中
2. 自定义指令名，就是`directives`属性的`key`值，创建的时候指令的名称不需要`v-`，使用时加`v-`
3. 自定义指令也是一个对象，先确定这个指令需要在哪个时间起作用。一共有5个钩子函数，跟`Vue`生命周期函数性质一样。[文档](https://cn.vuejs.org/v2/guide/custom-directive.html#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0)
    - bind
    - inserted
    - update
    - componentUpdated
    - unbind
4. 在钩子函数里写逻辑代码
    - 钩子函数的参数，除了 el 之外，其它参数都应该是只读的，切勿进行修改
    - 既然`binding`是只读的，我就存个变量里。保证引用地址不同，然后就修改这个新定义的变量就好了。binding 对象里的属性值不变。
    - 钩子函数在指定过程会接收到一些参数
      - el : 当前指令绑定的元素（原生）
      - binding: 对象
        -  name: 指令名称
        -  rawName: 包含v-的名称
        -  value: 指令的值，表达式值，被vue解析过
        -  oldValue
        -  expression: 指令的值（字符串值）
        -  arg
        -  modifiers

```javascript
<template>
  <div id="app" v-demo="message"></div>
</template>
<script>
export default {
  data () {
    return {
      message: 'hello!'
    }
  },
  directives: {
    demo: {
      bind: function (el, binding, vnode,oldVnode) {
        var str = binding.value

        if (typeof str !== 'string') return

        el.innerHTML = str.toUpperCase()
      }
    }
  }
}
```

修饰符：是通过钩子函数的第二个参数binding.modifiers获取，它是一个对象，如果你获取了，binding.modifiers.a === true 说明，在模板中使用了。如：v-demo:foo.a
然后我就通过判断：binding.modifiers.a 是不是等于 true
来写逻辑代码

```
<template>
  <div id="app" v-demo:foo.a="message"></div>
</template>
<script>
export default {
  data () {
    return {
      message: 'hello!'
    }
  },
  directives: {
    demo: {
      bind: function (el, binding, vnode) {
        var str = binding.value
        // 修饰符 a：我定义 -> 让字符串每个字符要被空格分隔开
        var isA = binding.modifiers.a

        if (typeof str !== 'string') return

        if (isA) {
          el.innerHTML = str.split('').join(' ').toUpperCase()
        } else {
          el.innerHTML = str.toUpperCase()
        }
      }
    }
  }
}
```


字符串形式的指令表达式 binding.expression，等号后面的 : 1+1 ，json 对象

传给指令的参数 binding.arg 冒号后面的 : 就是参数。number,string,object，读取了，能用啥就用啥

指令的绑定值 binding.value : 它，会把 **字符串形式的指令表达式** 运行一下，如：1+1=2, 字符串形式json 数据会解析成 json
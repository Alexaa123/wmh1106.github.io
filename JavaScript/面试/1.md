# 如何看待面试题

1. 拿到面试题，第一时间看到`考点`
2. 如何看待题海,`以不变应万变`
3. 如何看待以后遇到的题目：`题目到知识在到题目`

# 题目

## 1. js 中使用 typeof能得到哪些类型

JS 变量类型、变量计算 

-> 引申出

值类型 vs 引用类型，typeof 运算符详解（6种）

内存地址：对象赋值

引用类型：对象、函数、数组


## 2. 何时使用===何时使用==

强制类型转换

发生在：字符串拼接、==运算符、if 语句、逻辑运算

转换布尔值：`!!`

除了 `obj.a == null` 的情况下，其他都用三等。这里`obj.a === null || obj.a === undefined`(偏主观题)

## 3. JS 中有哪些内置函数

函数：
Object、Array、Boolean、Number、String、Function、Date、RegExp、Error

对象：
Math、JSON

## 4 JS 变量按照存储方式区分为哪些类型，并描述其特点

值类型：值的拷贝，复制

引用类型：地址的引用、共用一个内存块。节省内存空间

## 5 如何理解 JSON

JSON是一种数据格式，在 js 中，它是 js 内置的对象，有常用的2个 API

JSON.stringify({a:10,b:20})
JSON.parse('{"a":10,"b":20}')

## 6 原型和原型链

构造函数

```javascript
function Foo(name,age){
  this.name = name
  this.age = age
  this.class = 'class-1'
  // return this // 默认有这行
}

// 创建多个实例对象
var f1 = new Foo('zhangsan',21)// new 就是实例化的过程
var f2 = new Foo('lisi',22)
var f3 = new Foo('wangwu',23)
```

new Foo ：  this变成空对象{}，然后在 this.xxx = yyy，最后默认 return 出去 this。然后赋值给 f1、f2等，然后 f1就具有 name、age属性

```javascript
Foo.prototype.alertName = function(){
  alert(this.name)
}

f1.printName = function(){
  console.log(this.name)
}

f1.printName()
f1.alertName()
```


构造函数-扩展

原型规则和示例

5条规则：

1. 所有的引用类型（对象、函数、数组），都具有对象特性，即可自由扩展属性（除`null`以外）
2. 所有的引用类型（对象、函数、数组），都有一个`__proto__`属性，属性值是一个普通对象（除`null`以外）—— 隐式原型
3. 所有的函数都有一个`prototype`属性，属性值是一个普通对象 —— 显示原型
4. 所有的引用类型（对象、函数、数组），`__proto__`属性值指向（全等）它的构造函数的`prototype`属性值
5. 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的`__proto__`中寻找，（也就是去它的构造函数的 prototype）

原型链

```javascript
f1.toString() // 要去 f1.__proto__.__proto__中去找
```
![原型链查找](https://ws1.sinaimg.cn/large/006tKfTcgy1fpzax5fjm0j31i80ngmyo.jpg)

instanceof：用于判断`引用类型`属于哪个构造函数派生出来的

this 指向

循环对象自身的属性：obj.hasOwnProperty(attr)


## 7 如何准确判断一个变量是数组

`变量 instanceof Array`

## 8 写一个原型链继承的例子

```javascript
function Animal(){
  this.eat = function(){
    console.log('animal eat')
  }
}

function Dog(){
  this.bark = function(){
    console.log('dog bark')
  }
}

// 继承
Dog.prototype = new Animal()

var hashiqi = new Dog()
```

## 9 描述 new 一个对象的过程

1. 创建一个新对象
2. this 指向一个新对象性（空的）
3. 执行代码，即对 this 赋值（this.name = value）
4. 返回 this (默认就执行了，不用写 return)

## 10 zepto 或其他源码中，如何使用原型链

## 知识点

执行上下文

- 范围：一段`<script>`或者一个`函数`
- 全局：变量定义、函数声明 **一段`<script>`**
- 函数：变量定义、函数声明、this、arguments **`函数`**

this：要在执行时才能确认值，定义时无法确认

- 作为构造函数执行
- 作为对象属性执行
- 作为普通函数执行
- call、apply、bind

作用域：是定义时的作用域，而不是执行时的作用域。（做为闭包时）

- 没有块级作用域
- 函数和全局作用域

作用域链：一个自由变量，不断的往父作用域上找。

- 自由变量：当前作用域没有定义的变量

闭包

- 函数作为返回值（返回一个函数）
- 函数作为参数传递

## 11 变量提升的理解

- 变量定义
- 函数声明（注意和函数表达式的区别）

## 12 this几种不同的使用场景

- 作为构造函数执行
- 作为对象方法执行
- 作为普通函数执行
- call、apply、bind

## 13 用 js 创建10个a 标签，点击时弹出对应的序号

使用自执行函数，就是不用调用，只要定义完成就立刻执行的函数

```javascript
var i
for(i=1;i<=10;i++){
  (function(i){
    var a = document.createElement('a')
    a.innerHTML = i
    a.addEventListener('click',function(e){
      e.preventDefault()
      alert(i)
    })
    document.body.appendChild(a)
  })(i)
}
```

## 14 理解作用域

- 自由变量
- 作用域链，即自由变量的查找
- 闭包的两个场景

## 15 实际开发中闭包的应用

主要用于封装变量，收敛权限

```javascript
function isFirstLoad(){
  var _list = []
  return function(id){
    if(_list.indexOf(id) >= 0){
      return false
    }else{
      _list.push(id)
      return true
    }
  }
}

var firstLoad = isFirstLoad()
firstLoad(10) // true
firstLoad(10) // false
firstLoad(20) // true
```


## 16 知识点

## 17 



## 3. window.onload 和 DOMContentLoaded 的区别

浏览器渲染过程


## 5. 简述如何实现一个模块加载器，实现require.js的基本功能

JS 模块化

## 6. 实现数组的随机排序

 JS 基础算法




function createMarkup() {
  return {__html: '<div className="Pim">pim</div>'};
}

function MyComponent() {
  return <li dangerouslySetInnerHTML={createMarkup()} />;
}

arr.push(MyComponent())